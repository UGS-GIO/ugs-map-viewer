import maplibregl from 'maplibre-gl';
import { createSVGSymbol } from '@/lib/legend/symbol-generator';
import { Legend } from '@/lib/types/geoserver-types';
import { LegendProvider, RendererData } from './types';

/**
 * MapLibre-specific legend provider
 * Uses MapLibre layer paint properties and WMS endpoints for legends
 */
export class MapLibreLegend implements LegendProvider {
  constructor(private map: maplibregl.Map) {}

  async getRenderer(layerId: string): Promise<RendererData> {
    const style = this.map.getStyle();
    if (!style) {
      console.error('Map style not loaded');
      return;
    }

    const layers = style.layers?.filter(layer => layer.id === layerId) || [];
    if (layers.length === 0) {
      console.error(`Layer with id ${layerId} not found in map style`);
      return;
    }

    const layer = layers[0];

    if (!('source' in layer) || typeof layer.source !== 'string') {
      return this.getLegendFromPaint(layer, layerId);
    }

    const sourceId = layer.source;
    const source = style.sources?.[sourceId];

    if (source && typeof source === 'object' && 'tiles' in source) {
      return await this.getWMSLegend(sourceId, source);
    }

    return this.getLegendFromPaint(layer, layerId);
  }

  private getLegendFromPaint(layer: any, layerId: string): RendererData {
    try {
      if (!layer || !layer.type || !layer.paint) {
        return;
      }

      const paint = layer.paint;
      const sourceId = layer.source || '';
      const legendItems = [];

      if (layer.type === 'fill' && paint['fill-color']) {
        legendItems.push({
          type: 'regular-layer-renderer' as const,
          label: layer.id || 'Fill Layer',
          renderer: this.createColorSwatch(paint['fill-color'], 'fill'),
          id: layerId,
          url: sourceId,
        });
      }

      if (layer.type === 'line' && paint['line-color']) {
        legendItems.push({
          type: 'regular-layer-renderer' as const,
          label: layer.id || 'Line Layer',
          renderer: this.createColorSwatch(paint['line-color'], 'line'),
          id: layerId,
          url: sourceId,
        });
      }

      if (layer.type === 'circle' && paint['circle-color']) {
        legendItems.push({
          type: 'regular-layer-renderer' as const,
          label: layer.id || 'Circle Layer',
          renderer: this.createColorSwatch(paint['circle-color'], 'circle'),
          id: layerId,
          url: sourceId,
        });
      }

      if (layer.type === 'symbol' && layer.layout && layer.layout['icon-image']) {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("width", "32");
        svg.setAttribute("height", "20");
        svg.setAttribute("viewBox", "0 0 32 20");
        svg.style.display = "block";

        legendItems.push({
          type: 'regular-layer-renderer' as const,
          label: layer.id || 'Symbol Layer',
          renderer: svg,
          id: layerId,
          url: sourceId,
        });
      }

      return legendItems.length > 0 ? legendItems : undefined;
    } catch (error) {
      console.error('Error extracting legend from paint properties:', error);
      return;
    }
  }

  /**
   * Attempt to fetch WMS legend graphic
   * This is for WMS-based sources in MapLibre
   */
  private async getWMSLegend(sourceId: string, source: any): Promise<RendererData> {
    try {
      // Get WMS URL and layer name from source metadata
      const wmsUrl = source.metadata?.['wms-url'];
      const layerName = source.metadata?.['wms-layer'];

      if (!wmsUrl || !layerName) {
        console.warn(`Missing WMS metadata for source ${sourceId}, falling back to paint properties`);
        return this.getLegendFromPaint({ id: sourceId }, sourceId);
      }

      const legendUrl = `${wmsUrl}?service=WMS&request=GetLegendGraphic&format=application/json&layer=${layerName}&version=1.3.0`;

      const response = await fetch(legendUrl, {
        method: 'GET',
        headers: { Accept: 'application/json' },
      });

      if (!response.ok) {
        console.warn(`Failed to fetch WMS legend: ${response.status}`);
        return undefined;
      }

      // Check if response is actually JSON before parsing
      const contentType = response.headers.get('content-type');
      if (!contentType?.includes('application/json')) {
        console.warn(`WMS legend returned non-JSON content: ${contentType}`);
        return undefined;
      }

      const legendData: Legend = await response.json();
      const rules = legendData?.Legend?.[0]?.rules || [];

      if (rules.length === 0) {
        return undefined;
      }

      function isAutoGeneratedDefaultSymbolizer(rule: any) {
        const symbolizer = rule.symbolizers?.[0]?.Point;
        const graphic = symbolizer?.graphics?.[0];
        return rule.symbolizers?.length === 1 &&
          symbolizer &&
          symbolizer.graphics?.length === 1 &&
          graphic?.mark &&
          !graphic.fill &&
          !graphic.stroke;
      }

      const previews = [];

      for (const rule of rules) {
        const isAutoGeneratedDefault = isAutoGeneratedDefaultSymbolizer(rule);
        const label = rule.title || rule.name;

        if (isAutoGeneratedDefault) {
          const emptySvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          emptySvg.setAttribute("width", "32");
          emptySvg.setAttribute("height", "20");
          emptySvg.setAttribute("viewBox", "0 0 32 20");
          emptySvg.style.display = "block";
          emptySvg.style.visibility = "hidden";

          previews.push({
            type: 'regular-layer-renderer' as const,
            label: label,
            renderer: emptySvg,
            id: sourceId,
            url: wmsUrl,
          });
        } else {
          previews.push({
            type: 'regular-layer-renderer' as const,
            label: label,
            renderer: createSVGSymbol(rule.symbolizers),
            id: sourceId,
            url: wmsUrl,
          });
        }
      }

      return previews;
    } catch (error) {
      console.warn('Error fetching WMS legend, falling back to paint properties:', error);
      // Fall back to paint-based legend when WMS fails
      return this.getLegendFromPaint({ id: sourceId }, sourceId);
    }
  }

  /**
   * Helper to create a simple color swatch SVG
   */
  private createColorSwatch(color: any, type: 'fill' | 'line' | 'circle'): SVGSVGElement {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", "32");
    svg.setAttribute("height", "20");
    svg.setAttribute("viewBox", "0 0 32 20");
    svg.style.display = "block";

    let resolvedColor = color;
    // Handle simple color values
    if (typeof color === 'string') {
      resolvedColor = color;
    } else if (typeof color === 'object' && 'base' in color) {
      resolvedColor = color.base;
    }

    if (type === 'fill') {
      const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect.setAttribute("width", "32");
      rect.setAttribute("height", "20");
      rect.setAttribute("fill", resolvedColor);
      svg.appendChild(rect);
    } else if (type === 'line') {
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", "0");
      line.setAttribute("y1", "10");
      line.setAttribute("x2", "32");
      line.setAttribute("y2", "10");
      line.setAttribute("stroke", resolvedColor);
      line.setAttribute("stroke-width", "2");
      svg.appendChild(line);
    } else if (type === 'circle') {
      const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      circle.setAttribute("cx", "16");
      circle.setAttribute("cy", "10");
      circle.setAttribute("r", "6");
      circle.setAttribute("fill", resolvedColor);
      svg.appendChild(circle);
    }

    return svg;
  }
}
