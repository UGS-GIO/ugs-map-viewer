import { useQuery } from '@tanstack/react-query';
import { RendererFactory } from '@/lib/legend/renderer-factory';
import { createSVGSymbol } from '@/lib/legend/symbol-generator';
import { Legend, LegendRule } from '@/lib/types/geoserver-types';
import { RegularLayerRenderer } from '@/lib/types/mapping-types';
import { queryKeys } from '@/lib/query-keys';

/**
 * Check if a WMS legend rule is an auto-generated default symbolizer
 */
function isAutoGeneratedDefaultSymbolizer(rule: LegendRule): boolean {
    const symbolizer = rule.symbolizers?.[0]?.Point;
    const graphic = symbolizer?.graphics?.[0];
    return Boolean(
        rule.symbolizers?.length === 1 &&
        symbolizer &&
        symbolizer.graphics?.length === 1 &&
        graphic?.mark && !graphic.fill && !graphic.stroke
    );
}

/**
 * Simplified legend hook that fetches directly from WMS GetLegendGraphic
 * No map dependency - just needs the WMS URL and layer name
 */
const useLegendPreview = (_layerId: string, url: string, layerName?: string) => {
    const fetchLegendData = async () => {
        if (!url || !layerName) {
            return [];
        }

        const legendUrl = `${url}?service=WMS&request=GetLegendGraphic&format=application/json&layer=${layerName}&version=1.3.0`;

        try {
            const response = await fetch(legendUrl, {
                method: 'GET',
                headers: { Accept: 'application/json' },
            });

            if (!response.ok) {
                return [];
            }

            const contentType = response.headers.get('content-type');
            if (!contentType?.includes('application/json')) {
                return [];
            }

            const legendData: Legend = await response.json();
            const rules = legendData?.Legend?.[0]?.rules || [];

            if (rules.length === 0) {
                return [];
            }

            // Convert rules to preview format
            const previews: RegularLayerRenderer[] = rules.map((rule) => {
                const isAutoGenerated = isAutoGeneratedDefaultSymbolizer(rule);
                const label = rule.title || rule.name;

                if (isAutoGenerated) {
                    // Empty SVG for auto-generated defaults
                    const emptySvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    emptySvg.setAttribute("width", "32");
                    emptySvg.setAttribute("height", "20");
                    emptySvg.style.visibility = "hidden";
                    return {
                        type: 'regular-layer-renderer' as const,
                        label,
                        renderer: emptySvg,
                        id: layerName,
                        url,
                    };
                }

                return {
                    type: 'regular-layer-renderer' as const,
                    label,
                    renderer: createSVGSymbol(rule.symbolizers),
                    id: layerName,
                    url,
                };
            });

            // Generate preview HTML for each renderer
            const finalPreviews = await Promise.all(
                previews.map(async (item) => {
                    try {
                        return await RendererFactory.createPreview(item);
                    } catch {
                        return null;
                    }
                })
            );

            return finalPreviews.filter(Boolean);
        } catch {
            return [];
        }
    };

    const { data: preview = [], isLoading, error } = useQuery({
        queryKey: queryKeys.layers.legend(layerName || '', url),
        queryFn: fetchLegendData,
        enabled: !!url && !!layerName,
        staleTime: 1000 * 60 * 60, // Cache for 1 hour
    });

    return { preview, isLoading, error };
};

export default useLegendPreview;